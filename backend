# backend/main.py
import os
import sqlite3
import uuid
import datetime
from fastapi import FastAPI, Request, HTTPException
from pydantic import BaseModel
from typing import Optional
from dotenv import load_dotenv

# third-party
import openai
from twilio.rest import Client
from fastapi.middleware.cors import CORSMiddleware

# Load .env
load_dotenv()

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
TWILIO_ACCOUNT_SID = os.getenv("TWILIO_ACCOUNT_SID")
TWILIO_AUTH_TOKEN = os.getenv("TWILIO_AUTH_TOKEN")
TWILIO_PHONE = os.getenv("TWILIO_PHONE")
CALENDLY_LINK = os.getenv("CALENDLY_LINK", "https://calendly.com/your-event")
PUBLIC_BASE_URL = os.getenv("PUBLIC_BASE_URL", "")  # used in demo if needed

if not OPENAI_API_KEY:
    raise RuntimeError("Missing OPENAI_API_KEY in env")
openai.api_key = OPENAI_API_KEY

twilio_client = None
if TWILIO_ACCOUNT_SID and TWILIO_AUTH_TOKEN:
    twilio_client = Client(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)

DB_PATH = os.getenv("DATABASE_URL", "leads.sqlite3")

# --- DB setup (very small/simple) ---
def init_db():
    conn = sqlite3.connect(DB_PATH, check_same_thread=False)
    c = conn.cursor()
    c.execute("""
        CREATE TABLE IF NOT EXISTS leads (
            id TEXT PRIMARY KEY,
            name TEXT,
            phone TEXT,
            email TEXT,
            zip TEXT,
            enriched_json TEXT,
            sms_text TEXT,
            calendly_link TEXT,
            status TEXT,
            created_at TEXT
        )
    """)
    conn.commit()
    return conn

DB = init_db()

# --- FastAPI app ---
app = FastAPI(title="Agentic Engine - Backend (Phase 1)")

# allow local frontend dev
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- Pydantic models ---
class LeadIn(BaseModel):
    name: str
    phone: str
    email: Optional[str] = None
    zip: Optional[str] = None

# --- Helpers ---
def mock_enrich(lead: dict):
    # Quick, deterministic mock enrichment. Replace with ASU / Supermemory calls later.
    today = datetime.date.today()
    return {
        "life_stage": "new homeowner" if int(lead.get("zip", "0")[-1]) % 2 == 0 else "growing family",
        "current_insurer": "Allstate" if lead.get("name", "").lower().startswith("a") else "State Farm",
        "renewal_date": (today + datetime.timedelta(days=90)).isoformat(),
        "pain_point": "recent premium increase",
        "notes": f"Mock-enriched from zip {lead.get('zip')}"
    }

def save_lead_to_db(lead_id, lead_in, enriched, sms_text, calendly_link, status="new"):
    c = DB.cursor()
    c.execute("""
        INSERT INTO leads (id, name, phone, email, zip, enriched_json, sms_text, calendly_link, status, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    """, (
        lead_id,
        lead_in.get("name"),
        lead_in.get("phone"),
        lead_in.get("email"),
        lead_in.get("zip"),
        str(enriched),
        sms_text,
        calendly_link,
        status,
        datetime.datetime.utcnow().isoformat()
    ))
    DB.commit()

def update_lead_status(lead_id, status):
    c = DB.cursor()
    c.execute("UPDATE leads SET status=? WHERE id=?", (status, lead_id))
    DB.commit()

def get_lead(lead_id):
    c = DB.cursor()
    c.execute("SELECT id, name, phone, email, zip, enriched_json, sms_text, calendly_link, status, created_at FROM leads WHERE id=?", (lead_id,))
    row = c.fetchone()
    if not row:
        return None
    keys = ["id","name","phone","email","zip","enriched_json","sms_text","calendly_link","status","created_at"]
    return dict(zip(keys, row))

# --- OpenAI prompt generator ---
def generate_sms_text(enriched: dict, lead_in: dict, calendly_link: str):
    # Keep prompt small to save tokens
    prompt = f"""
You are a friendly local insurance agent. Write a short SMS (<=160 chars) in the prospect's tone.
Name: {lead_in.get('name')}
Life stage: {enriched.get('life_stage')}
Current insurer: {enriched.get('current_insurer')}
Renewal: {enriched.get('renewal_date')}
Pain point: {enriched.get('pain_point')}
Include a single call to action: a calendly link {calendly_link}
End by asking: "Reply YES to book."
Keep it casual, personal, 1-2 sentences only.
"""
    try:
        resp = openai.ChatCompletion.create(
            model="gpt-4o-mini",  # fallback; pick the best available in your account
            messages=[{"role":"user","content":prompt}],
            max_tokens=120,
            temperature=0.5
        )
        text = resp["choices"][0]["message"]["content"].strip()
        # Truncate to 160 chars just to be safe
        return text[:160]
    except Exception as e:
        # fallback canned message
        return f"Hi {lead_in.get('name')}, congrats on the {enriched.get('life_stage')}! Quick 5-min quote? {calendly_link} Reply YES to book."

# --- Twilio send (if configured) ---
def send_sms_via_twilio(to_phone: str, text: str):
    if not twilio_client:
        raise RuntimeError("Twilio not configured")
    msg = twilio_client.messages.create(body=text, from_=TWILIO_PHONE, to=to_phone)
    return msg.sid

# --- Endpoints ---
@app.post("/lead")
async def create_lead(payload: LeadIn):
    lead_dict = payload.dict()
    lead_id = str(uuid.uuid4())
    enriched = mock_enrich(lead_dict)

    # Create a calendly link per-lead (could append params)
    calendly_link = CALENDLY_LINK
    # generate SMS text via OpenAI (or fallback)
    sms_text = generate_sms_text(enriched, lead_dict, calendly_link)

    # Save to DB as "sms_sent" if we actually call Twilio; initial status "sms_sent" or "new"
    status = "sms_sent"
    try:
        if twilio_client:
            sid = send_sms_via_twilio(lead_dict["phone"], sms_text)
            status = "sms_sent"
        else:
            # Twilio not configured: keep status as "pending_sms" and allow demo to show generated SMS
            status = "pending_sms"
    except Exception as e:
        status = "sms_error"

    save_lead_to_db(lead_id, lead_dict, enriched, sms_text, calendly_link, status=status)

    return {"lead_id": lead_id, "enriched": enriched, "sms_text": sms_text, "status": status}

@app.post("/webhook/sms")
async def twilio_inbound(request: Request):
    """
    Twilio will POST form-encoded data to this endpoint on inbound SMS.
    We're looking for From and Body. If Body contains "yes" -> mark booked.
    """
    form = await request.form()
    from_number = form.get("From")
    body = form.get("Body", "")
    if not from_number:
        raise HTTPException(status_code=400, detail="Missing From in webhook")

    # naive mapping: find lead with matching phone
    c = DB.cursor()
    c.execute("SELECT id FROM leads WHERE phone=?", (from_number,))
    row = c.fetchone()
    if not row:
        # no lead found â€” return 200 so Twilio stops retries
        return "OK"
    lead_id = row[0]
    lowered = body.strip().lower()
    if "yes" in lowered or "y" == lowered:
        update_lead_status(lead_id, "booked")
    else:
        update_lead_status(lead_id, "replied:" + (body[:100]))
    return "OK"

@app.post("/webhook/calendly")
async def calendly_webhook(request: Request):
    """
    If you configure Calendly webhooks, they will call you when an event is scheduled.
    For a simple demo, Calendly can redirect to a 'thank you' URL that hits this endpoint.
    Expect JSON with a recognizable payload. Here we accept a minimal shape:
    { "lead_phone": "+12223334444", "event":"scheduled" }
    """
    data = await request.json()
    lead_phone = data.get("lead_phone")
    if not lead_phone:
        return {"ok": False, "reason": "no lead_phone"}
    c = DB.cursor()
    c.execute("SELECT id FROM leads WHERE phone=?", (lead_phone,))
    row = c.fetchone()
    if not row:
        return {"ok": False, "reason": "lead not found"}
    lead_id = row[0]
    update_lead_status(lead_id, "booked")
    return {"ok": True, "lead_id": lead_id}

@app.get("/lead/{lead_id}")
async def read_lead(lead_id: str):
    lead = get_lead(lead_id)
    if not lead:
        raise HTTPException(status_code=404, detail="lead not found")
    return lead

@app.get("/health")
def health():
    return {"ok": True}
